# -*- coding: utf-8 -*-
"""2nd model

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_PYWL0lx5jHED4Vwl8cVSp2OR77Hni2h
"""

import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.optimize import Bounds

# Define fixed values for parameters
nu = 1e-06
rho = 1000
r_o = 35 * 1e-03
u_Rm = 30
k = 0.4
R = 70 * 1e-03
u = 1
L = 170 * 1e-03
eta = r_o / R
H = R - r_o
D = R * 2

# Load experimental and measured data
experiment_data = pd.read_excel('experiment_data.xlsx')
measured_data = pd.read_excel('measured_data.xlsx')

# Create a custom color palette for consistency
palette = {
    'blue': '#1f77b4',
    'orange': '#ff7f0e',
    'red': '#d62728',
    'green': '#2ca02c',
}

# Define a custom style for the plots
plt.style.use('seaborn-whitegrid')

# Set a custom figure size for all plots
plt.figure(figsize=(8, 6))

# Function to calculate the expression
def calculate_expression(x_drag, a, b, c, nu, D):
    y_new_value = 4 * np.log10(x_drag) + (1 / np.sqrt(2)) * (a - b * c**(nu / (D * np.sqrt(2)) * x_drag)) - 0.4
    return y_new_value

# Define the objective function for optimization (single objective for the entire dataset)
def objective(coefficients, x_drag_values, y_drag_values):
    a, b, c = coefficients
    calculated_results = calculate_expression(x_drag_values, a, b, c, nu, D)  # Pass nu and D as arguments
    squared_errors = (calculated_results - y_drag_values) ** 2
    total_squared_error = sum(squared_errors)
    return total_squared_error

# Use the entire x_drag and y_drag values from the dataset
x_drag_values = experiment_data['x_drag'].values
y_drag_values = experiment_data['y_drag'].values

# Define lower and upper bounds for each parameter
# Replace these values with your desired bounds
lower_a, upper_a = 0, 100
lower_b, upper_b = 0, 100
lower_c, upper_c = 0.000025413, 100

# Create a Bounds object with the parameter bounds
parameter_bounds = Bounds([lower_a, lower_b, lower_c], [upper_a, upper_b, upper_c])

# Define the initial guess for the coefficients
initial_guess = [1.0, 1.0, 0.01]  # Replace with appropriate initial values

# Perform optimization to find the optimal a, b, and c values for the entire dataset
result_opt = minimize(objective, initial_guess, args=(x_drag_values, y_drag_values), method='L-BFGS-B', bounds=parameter_bounds)
optimized_coefficients = result_opt.x

# Calculate the y_new_values for the entire dataset using the optimized coefficients
y_new_values = calculate_expression(x_drag_values, *optimized_coefficients, nu, D)

# Create a DataFrame to store the results
results_df = pd.DataFrame({'x_drag': x_drag_values, 'y_drag': y_drag_values, 'y_new_value': y_new_values})

# Print the optimized coefficients
print("Optimized Coefficients:")
print("a:", optimized_coefficients[0])
print("b:", optimized_coefficients[1])
print("c:", optimized_coefficients[2])

# Define custom line styles and colors
exp_color = palette['red']
calc_color = palette['green']  # Change the color to green
calc_line_style = '--'  # Use a dashed line style for calculated results

# Create a figure with a larger size and adjust marker size
plt.figure(figsize=(10, 8))
plt.scatter(
    experiment_data['x_drag'], experiment_data['y_drag'],
    label='Experimental Data', color=exp_color, alpha=0.7, s=80, edgecolors='k', marker='*'  # Use stars for markers
)
plt.plot(
    results_df['x_drag'], results_df['y_new_value'],
    label='Calculated Results', color=calc_color, alpha=0.7, linewidth=2.5, linestyle=calc_line_style  # Use a dashed line for calculated results
)

# Adjust axis labels and title font size
plt.xlabel('$\sqrt{Re_c * f}$', fontsize=16)
plt.ylabel('$1/\sqrt{f}$', fontsize=16)
plt.title('Comparison of Experimental Data and Calculated Results', fontsize=18)

# Set log scale for both x and y axes
plt.xscale('log')
plt.yscale('log')

# Increase font size for the legend and place it at the upper left corner
plt.legend(fontsize=14, loc='upper left')

# Add a grid with a dashed line style
plt.grid(True, linestyle='--', alpha=0.5)

# Increase font size for axis tick labels
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)

# Create a table to display parameter values
parameter_table_data = [
    ["Parameter", "Value"],
    ["a", f"{optimized_coefficients[0]:.2f}"],
    ["b", f"{optimized_coefficients[1]:.2f}"],
    ["c", f"{optimized_coefficients[2]:.4e}"],
]

# Create the table and position it under the legend with reduced size
table = plt.table(cellText=parameter_table_data, loc='lower right', cellLoc='center', colWidths=[0.2, 0.2])
table.auto_set_font_size(False)
table.set_fontsize(12)  # Adjust the font size for the smaller table
table.scale(1, 1.2)  # Adjust the table size (scale factor of 0.7 to make it smaller)


# Show the improved plot with the table
plt.show()


# Adjust plot margins
plt.tight_layout()

# Save the figure in high resolution (e.g., 300 dpi) for publication
plt.savefig('improved_plot.png', dpi=300)

# Show the improved plot
plt.show()



# Calculate the relative deviation for each data point
results_df['relative_deviation'] = ((results_df['y_drag'] - results_df['y_new_value']) / results_df['y_drag']) * 100

# Print the first few rows of the DataFrame with the relative deviation
print(results_df[['x_drag', 'y_drag', 'y_new_value', 'relative_deviation']].head())

# Plot the relative deviation as a function of x_drag
plt.figure(figsize=(8, 6))
plt.plot(results_df['x_drag'], results_df['relative_deviation'], color='red')
plt.xlabel('$\sqrt{Re_c * f}$', fontsize=16)
plt.ylabel('Relative Deviation (%)', fontsize=16)
plt.title('Relative Deviation between Experimental and Measured Data', fontsize=18)
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.show()

# Adjust plot margins
plt.tight_layout()

# Save the figure in high resolution (e.g., 300 dpi) for publication
plt.savefig('relative_deviation_plot.png', dpi=300)

# Show the relative deviation plot
plt.show()